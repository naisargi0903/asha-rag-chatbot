# -*- coding: utf-8 -*-
"""CareerPathGuidance.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J6ClzPS6CD8h_FdhSK2OAtSbOob2bLoV
"""

import requests
import json
import networkx as nx
import matplotlib.pyplot as plt
from typing import Dict, List, Any, Optional, Union
import random
from collections import defaultdict
import re
import datetime as datetime
from src.tools.tool_registry import BaseTool, register_tool
from pathlib import Path
import os
from dotenv import load_dotenv

load_dotenv()

class CareerPathAnalyzerTool:
    """
    Career Path Analyzer Tool for an agentic AI chatbot that visualizes career paths based on skills and aspirations.
    Uses a graph-based approach to map potential career trajectories and provide insights.
    """

    def __init__(self, api_key: Optional[str] = None):
        """
        Initialize the CareerPathAnalyzerTool.

        Args:
            api_key: Optional API key for external data sources (not required for demo version)
        """
        self.srp_api_key = os.getenv('SRP_API_KEY')
        self.news_api_key = os.getenv('NEWS_API_KEY')
        self.api_key = api_key
        self.career_graph = nx.DiGraph()
        self.skills_database = {
            "Python": ["Junior Developer", "Mid-level Developer", "Senior Developer"],
            "JavaScript": ["Junior Developer", "Mid-level Developer", "Senior Developer"],
            "SQL": ["Junior Developer", "Mid-level Developer"],
            "System Design": ["Mid-level Developer", "Senior Developer", "Tech Lead"],
            "Project Management": ["Tech Lead", "Engineering Manager"],
            "Leadership": ["Tech Lead", "Engineering Manager", "Director of Engineering"]
        }
        self.industry_database = {
            "Technology": ["Junior Developer", "Mid-level Developer", "Senior Developer", "Tech Lead", "Engineering Manager"],
            "Finance": ["Financial Analyst", "Senior Financial Analyst", "Finance Manager"],
            "Healthcare": ["Registered Nurse", "Charge Nurse", "Nurse Manager"],
            "Marketing": ["Marketing Assistant", "Marketing Specialist", "Marketing Manager"]
        }
        self._load_career_data()

    def _load_career_data(self):
        """
        Load career progression data into the graph.
        In a production version, this would fetch data from LinkedIn or similar APIs.
        For demo purposes, we'll use hard-coded sample data.
        """
        self._build_career_graph()

    def _build_career_graph(self):
        """Build the career progression graph."""
        try:
            # Add source and sink nodes
            self.career_graph.add_node("source", roles=["Technology"])
            self.career_graph.add_node("sink", roles=["Leadership"])
            
            # Add role nodes
            roles = [
                "Junior Developer", "Mid-Level Developer", "Senior Developer",
                "Tech Lead", "Engineering Manager", "CTO",
                "Data Analyst", "Data Scientist", "Data Engineer",
                "Machine Learning Engineer", "AI Researcher",
                "DevOps Engineer", "Cloud Architect",
                "Product Manager", "Technical Product Manager"
            ]
            
            for role in roles:
                self.career_graph.add_node(role)
            
            # Add edges with weights
            edges = [
                # Developer path
                ("source", "Junior Developer", 1.0),
                ("Junior Developer", "Mid-Level Developer", 0.8),
                ("Mid-Level Developer", "Senior Developer", 0.7),
                ("Senior Developer", "Tech Lead", 0.6),
                ("Tech Lead", "Engineering Manager", 0.5),
                ("Engineering Manager", "CTO", 0.4),
                
                # Data path
                ("source", "Data Analyst", 1.0),
                ("Data Analyst", "Data Scientist", 0.8),
                ("Data Scientist", "Data Engineer", 0.7),
                ("Data Engineer", "Machine Learning Engineer", 0.6),
                ("Machine Learning Engineer", "AI Researcher", 0.5),
                
                # DevOps path
                ("source", "DevOps Engineer", 1.0),
                ("DevOps Engineer", "Cloud Architect", 0.7),
                
                # Product path
                ("source", "Product Manager", 1.0),
                ("Product Manager", "Technical Product Manager", 0.8)
            ]
            
            for source, target, weight in edges:
                self.career_graph.add_edge(source, target, weight=weight)
            
            # Add cross-path transitions
            cross_edges = [
                # Developer to Data
                ("Senior Developer", "Data Engineer", 0.5),
                ("Senior Developer", "Machine Learning Engineer", 0.4),
                
                # Developer to DevOps
                ("Senior Developer", "DevOps Engineer", 0.6),
                ("Senior Developer", "Cloud Architect", 0.5),
                
                # Developer to Product
                ("Senior Developer", "Technical Product Manager", 0.4),
                
                # Data to Leadership
                ("Data Scientist", "Engineering Manager", 0.3),
                ("Machine Learning Engineer", "CTO", 0.2),
                
                # DevOps to Leadership
                ("Cloud Architect", "Engineering Manager", 0.4),
                ("Cloud Architect", "CTO", 0.3),
                
                # Product to Leadership
                ("Technical Product Manager", "Engineering Manager", 0.5),
                ("Technical Product Manager", "CTO", 0.4)
            ]
            
            for source, target, weight in cross_edges:
                self.career_graph.add_edge(source, target, weight=weight)
            
            # Add final transitions to sink
            for role in ["Engineering Manager", "CTO", "AI Researcher"]:
                self.career_graph.add_edge(role, "sink", weight=0.3)
            
        except Exception as e:
            logger.error(f"Error building career graph: {str(e)}")
            raise

    def _fetch_srp_data(self, query: str) -> Dict[str, Any]:
        """
        Fetch career-related data from SRP API.

        Args:
            query: Search query for career information

        Returns:
            Dictionary containing career data from SRP
        """
        try:
            url = f"https://api.serphouse.com/serp"
            params = {
                "api_key": self.srp_api_key,
                "q": query,
                "domain": "google.com",
                "lang": "en",
                "type": "web"
            }
            response = requests.get(url, params=params)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error fetching SRP data: {e}")
            return {}

    def _fetch_news_data(self, query: str) -> Dict[str, Any]:
        """
        Fetch career-related news from News API.
        
        Args:
            query: Search query for career news

        Returns:
            Dictionary containing relevant news articles
        """
        try:
            url = "https://newsapi.org/v2/everything"
            params = {
                "apiKey": self.news_api_key,
                "q": query,
                "sortBy": "relevancy",
                "language": "en",
                "pageSize": 5
            }
            response = requests.get(url, params=params)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error fetching news data: {e}")
            return {}

    def get_career_insights(self, role: str, skills: List[str]) -> Dict[str, Any]:
        """
        Get comprehensive career insights using both local data and external APIs.

        Args:
            role: Target career role
            skills: List of relevant skills

        Returns:
            Dictionary containing career insights
        """
        # Combine role and skills for better search results
        search_query = f"{role} career path requirements skills {' '.join(skills)}"
        
        # Fetch data from both APIs
        srp_data = self._fetch_srp_data(search_query)
        news_data = self._fetch_news_data(f"{role} technology career trends")
        
        # Extract relevant information
        insights = {
            "role_description": self._extract_role_info(srp_data),
            "required_skills": self._extract_skill_requirements(srp_data),
            "market_trends": self._extract_market_trends(news_data),
            "learning_resources": self._extract_learning_resources(srp_data),
            "career_opportunities": self._extract_career_opportunities(srp_data, news_data)
        }
        
        return insights

    def _extract_role_info(self, srp_data: Dict[str, Any]) -> Dict[str, str]:
        """Extract role information from SRP data."""
        role_info = {
            "description": "",
            "responsibilities": [],
            "average_salary": "",
            "experience_levels": []
        }
        
        if "organic_results" in srp_data:
            for result in srp_data["organic_results"]:
                if "snippet" in result:
                    # Extract relevant information using regex patterns
                    salary_pattern = r"\$[\d,]+ - \$[\d,]+"
                    exp_pattern = r"(\d+[-\s]?\d*)\s*(?:years?|yrs)"
                    
                    # Update role info based on found patterns
                    if not role_info["description"]:
                        role_info["description"] = result["snippet"]
                    
                    salary_match = re.search(salary_pattern, result["snippet"])
                    if salary_match and not role_info["average_salary"]:
                        role_info["average_salary"] = salary_match.group(0)
                    
                    exp_match = re.search(exp_pattern, result["snippet"])
                    if exp_match:
                        role_info["experience_levels"].append(exp_match.group(1))
        
        return role_info

    def _extract_skill_requirements(self, srp_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extract skill requirements from SRP data."""
        skills = []
        if "organic_results" in srp_data:
            skill_patterns = {
                "technical": r"(?:required|technical|programming|development)\s+skills?:?\s*((?:[\w+#\-\.]+(?:,\s*)?)+)",
                "soft": r"(?:soft|interpersonal|communication)\s+skills?:?\s*((?:[\w+\-\s]+(?:,\s*)?)+)"
            }
            
            for result in srp_data["organic_results"]:
                if "snippet" in result:
                    for skill_type, pattern in skill_patterns.items():
                        matches = re.findall(pattern, result["snippet"], re.IGNORECASE)
                        for match in matches:
                            skills.extend([{
                                "name": skill.strip(),
                                "type": skill_type,
                                "importance": "high" if skill_type == "technical" else "medium"
                            } for skill in match.split(",")])
        
        return list({skill["name"]: skill for skill in skills}.values())

    def _extract_market_trends(self, news_data: Dict[str, Any]) -> List[Dict[str, str]]:
        """Extract market trends from news data."""
        trends = []
        if "articles" in news_data:
            for article in news_data["articles"][:5]:  # Get top 5 relevant articles
                trends.append({
                    "title": article.get("title", ""),
                    "description": article.get("description", ""),
                    "url": article.get("url", ""),
                    "date": article.get("publishedAt", "")
                })
        return trends

    def _extract_learning_resources(self, srp_data: Dict[str, Any]) -> List[Dict[str, str]]:
        """Extract learning resources from SRP data."""
        resources = []
        if "organic_results" in srp_data:
            resource_patterns = [
                r"(?:course|tutorial|certification|training)(?:[:\s]+)([\w\s]+)(?:at|on|by|from)\s+([\w\s\.]+)",
                r"([\w\s]+(?:course|tutorial|certification))(?:\s+at|on|by|from)\s+([\w\s\.]+)"
            ]
            
            for result in srp_data["organic_results"]:
                if "snippet" in result:
                    for pattern in resource_patterns:
                        matches = re.findall(pattern, result["snippet"], re.IGNORECASE)
                        for match in matches:
                            resources.append({
                                "name": match[0].strip(),
                                "provider": match[1].strip(),
                                "url": result.get("link", "")
                            })
        
        return list({resource["name"]: resource for resource in resources}.values())

    def _extract_career_opportunities(self, srp_data: Dict[str, Any], news_data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract career opportunities from both SRP and news data."""
        opportunities = {
            "job_trends": [],
            "growing_sectors": [],
            "companies_hiring": []
        }
        
        # Extract from SRP data
        if "organic_results" in srp_data:
            company_pattern = r"(?:at|with|for)\s+([\w\s]+)(?:is|are)\s+(?:hiring|recruiting|looking)"
            for result in srp_data["organic_results"]:
                if "snippet" in result:
                    companies = re.findall(company_pattern, result["snippet"], re.IGNORECASE)
                    opportunities["companies_hiring"].extend(companies)
        
        # Extract from news data
        if "articles" in news_data:
            for article in news_data["articles"]:
                if "description" in article:
                    if "growth" in article["description"].lower() or "demand" in article["description"].lower():
                        opportunities["job_trends"].append({
                            "trend": article["title"],
                            "source": article["source"]["name"] if "source" in article else "",
                            "date": article["publishedAt"]
                        })
        
        # Remove duplicates
        opportunities["companies_hiring"] = list(set(opportunities["companies_hiring"]))
        
        return opportunities

    def recommend_career_path(self,
                           current_role: str,
                           skills: List[str],
                           aspirations: List[str] = None,
                           industry_preference: str = None,
                           years_experience: int = 0,
                           prioritize_skills: bool = False) -> Dict[str, Any]:
        """
        Recommend a career path based on current role, skills, and aspirations.

        Args:
            current_role: Current job role
            skills: List of current skills
            aspirations: Optional list of career aspirations
            industry_preference: Optional preferred industry
            years_experience: Years of experience
            prioritize_skills: Whether to prioritize skills over other factors

        Returns:
            Dictionary containing career path recommendation
        """
        # For demo purposes, return a simple recommendation
        return {
            "current_role": current_role,
            "next_roles": [
                {"role": "Mid-level Developer", "probability": 0.8, "time_to_transition": 2},
                {"role": "Senior Developer", "probability": 0.6, "time_to_transition": 4}
            ],
            "skill_gaps": {
                "System Design": "High",
                "Architecture": "Medium",
                "Team Leadership": "Low"
            },
            "learning_paths": [
                "Complete System Design course",
                "Take Leadership training",
                "Learn advanced architecture patterns"
            ]
        }

    def generate_career_report(self, recommendation: Dict[str, Any], detailed: bool = False) -> str:
        """
        Generate a career report based on the recommendation.

        Args:
            recommendation: Career path recommendation
            detailed: Whether to include detailed information

        Returns:
            Formatted career report string
        """
        report = f"Career Path Analysis for {recommendation['current_role']}\n\n"
        
        if detailed:
            report += "Next Role Opportunities:\n"
            for role in recommendation['next_roles']:
                report += f"- {role['role']} (Probability: {role['probability']*100}%, Time: {role['time_to_transition']} years)\n"
            
            report += "\nSkill Gaps to Address:\n"
            for skill, priority in recommendation['skill_gaps'].items():
                report += f"- {skill} ({priority} priority)\n"
            
            report += "\nRecommended Learning Paths:\n"
            for path in recommendation['learning_paths']:
                report += f"- {path}\n"
        
        return report

    def suggest_learning_resources(self, skills: List[str]) -> Dict[str, List[str]]:
        """
        Suggest learning resources for given skills.

        Args:
            skills: List of skills to find resources for

        Returns:
            Dictionary mapping skills to learning resources
        """
        resources = {
            "System Design": [
                "System Design Interview Course",
                "Designing Data-Intensive Applications book",
                "System Design Primer GitHub repository"
            ],
            "Architecture": [
                "Clean Architecture book",
                "Software Architecture Patterns course",
                "Microservices Design Patterns"
            ],
            "Team Leadership": [
                "Leadership in Tech course",
                "The Manager's Path book",
                "Technical Leadership workshop"
            ]
        }
        
        return {skill: resources.get(skill, []) for skill in skills}

@register_tool
class CareerPathTool(BaseTool):
    """Tool for analyzing and providing career path guidance using dynamic data from APIs."""
    
    def __init__(self):
        """Initialize the CareerPathTool."""
        super().__init__(
            name="career_path",
            description="Analyzes career paths and provides personalized guidance based on real-time data"
        )
        self.data_dir = Path("data")
        self.resources_file = self.data_dir / "career_resources.json"
        self.trends_file = self.data_dir / "market_trends.json"
        self.insights_file = self.data_dir / "career_insights.json"
        self.srp_api_key = os.getenv('SRP_API_KEY')
        self.news_api_key = os.getenv('NEWS_API_KEY')
        self._ensure_data_files_exist()
        
    def _ensure_data_files_exist(self):
        """Ensure all required data files exist."""
        self.data_dir.mkdir(exist_ok=True)
        
        # Initialize files if they don't exist
        for file_path in [self.resources_file, self.trends_file, self.insights_file]:
            if not file_path.exists():
                with open(file_path, 'w') as f:
                    json.dump({"last_updated": "", "data": {}}, f)

    def _load_json_data(self, file_path: Path) -> Dict:
        """Load data from a JSON file."""
        try:
            with open(file_path, 'r') as f:
                return json.load(f)
        except (json.JSONDecodeError, FileNotFoundError):
            return {"last_updated": "", "data": {}}

    def _save_json_data(self, file_path: Path, data: Dict):
        """Save data to a JSON file."""
        with open(file_path, 'w') as f:
            json.dump(data, f, indent=4)

    def _fetch_and_update_resources(self, query: str):
        """Fetch and update career resources using SRP API."""
        try:
            # Fetch data from SRP API
            srp_data = self._fetch_srp_data(f"career resources {query}")
            
            # Load existing data
            resources_data = self._load_json_data(self.resources_file)
            
            # Extract and update learning resources
            if "organic_results" in srp_data:
                for result in srp_data["organic_results"]:
                    resource = {
                        "title": result.get("title", ""),
                        "description": result.get("snippet", ""),
                        "url": result.get("link", ""),
                        "source": result.get("source", ""),
                        "date_found": datetime.datetime.now().isoformat()
                    }
                    
                    # Categorize resource
                    if "python" in query.lower():
                        resources_data["learning_resources"]["python_development"].append(resource)
                    elif "web" in query.lower():
                        resources_data["learning_resources"]["web_development"].append(resource)
                    # Add more categories as needed
            
            # Update timestamp
            resources_data["last_updated"] = datetime.datetime.now().isoformat()
            
            # Save updated data
            self._save_json_data(self.resources_file, resources_data)
            
        except Exception as e:
            print(f"Error updating resources: {e}")

    def _fetch_and_update_trends(self, query: str):
        """Fetch and update market trends using News API."""
        try:
            # Fetch data from News API
            news_data = self._fetch_news_data(f"technology career trends {query}")
            
            # Load existing data
            trends_data = self._load_json_data(self.trends_file)
            
            # Extract and update trends
            if "articles" in news_data:
                for article in news_data["articles"]:
                    trend = {
                        "title": article.get("title", ""),
                        "description": article.get("description", ""),
                        "url": article.get("url", ""),
                        "source": article.get("source", {}).get("name", ""),
                        "date_published": article.get("publishedAt", ""),
                        "date_found": datetime.datetime.now().isoformat()
                    }
                    
                    # Categorize trend
                    if "software" in query.lower():
                        trends_data["industry_trends"]["software_development"].append(trend)
                    elif "data" in query.lower():
                        trends_data["industry_trends"]["data_science"].append(trend)
                    # Add more categories as needed
            
            # Update timestamp
            trends_data["last_updated"] = datetime.datetime.now().isoformat()
            
            # Save updated data
            self._save_json_data(self.trends_file, trends_data)
            
        except Exception as e:
            print(f"Error updating trends: {e}")

    def _fetch_and_update_insights(self, query: str):
        """Fetch and update career insights using SRP API."""
        try:
            # Fetch data from SRP API
            srp_data = self._fetch_srp_data(f"career advice {query}")
            
            # Load existing data
            insights_data = self._load_json_data(self.insights_file)
            
            # Extract and update insights
            if "organic_results" in srp_data:
                for result in srp_data["organic_results"]:
                    insight = {
                        "title": result.get("title", ""),
                        "description": result.get("snippet", ""),
                        "url": result.get("link", ""),
                        "source": result.get("source", ""),
                        "date_found": datetime.datetime.now().isoformat()
                    }
                    
                    # Categorize insight
                    if "entry" in query.lower() or "junior" in query.lower():
                        insights_data["career_advice"]["entry_level"]["tips"].append(insight)
                    elif "senior" in query.lower():
                        insights_data["career_advice"]["senior_level"]["tips"].append(insight)
                    else:
                        insights_data["career_advice"]["mid_level"]["tips"].append(insight)
            
            # Update timestamp
            insights_data["last_updated"] = datetime.datetime.now().isoformat()
            
            # Save updated data
            self._save_json_data(self.insights_file, insights_data)
            
        except Exception as e:
            print(f"Error updating insights: {e}")

    def _execute(self, query: str, **kwargs) -> str:
        """
        Execute the career path analysis based on the query.

        Args:
            query: User's query about career guidance
            **kwargs: Additional parameters

        Returns:
            Formatted career guidance response
        """
        try:
            # Extract key information from query
            career_stage = self._extract_career_stage(query)
            field = self._extract_field(query)
            
            # Update data from APIs
            self._fetch_and_update_resources(f"{field} {career_stage}")
            self._fetch_and_update_trends(f"{field} {career_stage}")
            self._fetch_and_update_insights(f"{field} {career_stage}")
            
            # Load all data
            resources = self._load_json_data(self.resources_file)
            trends = self._load_json_data(self.trends_file)
            insights = self._load_json_data(self.insights_file)
            
            # Generate response
            response = self._generate_response(query, resources, trends, insights)
            
            return response
            
        except Exception as e:
            return f"Error processing request: {e}"

    def _extract_career_stage(self, query: str) -> str:
        """Extract career stage from query."""
        if any(word in query.lower() for word in ["entry", "junior", "beginner", "start"]):
            return "entry_level"
        elif any(word in query.lower() for word in ["senior", "lead", "expert"]):
            return "senior_level"
        return "mid_level"

    def _extract_field(self, query: str) -> str:
        """Extract technical field from query."""
        if "python" in query.lower():
            return "python_development"
        elif "web" in query.lower():
            return "web_development"
        elif "data" in query.lower():
            return "data_science"
        # Add more fields as needed
        return "software_development"

    def _generate_response(self, query: str, resources: Dict, trends: Dict, insights: Dict) -> str:
        """Generate a formatted response based on the data."""
        field = self._extract_field(query)
        career_stage = self._extract_career_stage(query)
        
        response = []
        
        # Add career advice
        if insights.get("career_advice", {}).get(career_stage, {}).get("tips"):
            response.append("## Career Advice")
            tips = insights["career_advice"][career_stage]["tips"][:3]  # Get top 3 tips
            for tip in tips:
                response.append(f"- {tip['title']}")
                response.append(f"  {tip['description']}\n")
        
        # Add learning resources
        if resources.get("learning_resources", {}).get(field):
            response.append("## Learning Resources")
            learning_resources = resources["learning_resources"][field][:3]  # Get top 3 resources
            for resource in learning_resources:
                response.append(f"- [{resource['title']}]({resource['url']})")
                response.append(f"  {resource['description']}\n")
        
        # Add market trends
        if trends.get("industry_trends", {}).get(field):
            response.append("## Latest Industry Trends")
            field_trends = trends["industry_trends"][field][:3]  # Get top 3 trends
            for trend in field_trends:
                response.append(f"- {trend['title']}")
                response.append(f"  {trend['description']}\n")
        
        return "\n".join(response)

    def _fetch_srp_data(self, query: str) -> Dict[str, Any]:
        """Fetch data from SRP API."""
        try:
            url = f"https://api.serphouse.com/serp"
            params = {
                "api_key": self.srp_api_key,
                "q": query,
                "domain": "google.com",
                "lang": "en",
                "type": "web"
            }
            response = requests.get(url, params=params)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error fetching SRP data: {e}")
            return {}

    def _fetch_news_data(self, query: str) -> Dict[str, Any]:
        """Fetch data from News API."""
        try:
            url = "https://newsapi.org/v2/everything"
            params = {
                "apiKey": self.news_api_key,
                "q": query,
                "sortBy": "relevancy",
                "language": "en",
                "pageSize": 5
            }
            response = requests.get(url, params=params)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"Error fetching news data: {e}")
            return {}

class CareerPathVisualizer:
    """
    A visualization class for rendering career path and gender gap visualizations.
    This would be implemented with a proper visualization library in a real application.
    """

    def render_career_timeline(self, career_path_data: Dict[str, Any]) -> str:
        """
        Render a career timeline visualization.

        Args:
            career_path_data: Career path visualization data

        Returns:
            HTML string with visualization
        """
        if "error" in career_path_data:
            return f"<div class='error'>{career_path_data['error']}</div>"

        html = [
            "<div class='career-timeline'>",
            f"<h3>{career_path_data['title']}</h3>",
            "<div class='timeline-container'>"
        ]

        for stage in career_path_data.get("stages", []):
            html.append("<div class='timeline-stage'>")
            html.append(f"<div class='timeline-year'>{stage['title']}</div>")
            html.append(f"<div class='timeline-role'>{stage['role']}</div>")

            if stage.get("skills"):
                html.append("<div class='timeline-skills'>")
                html.append("<strong>Skills to develop:</strong>")
                html.append("<ul>")
                for skill in stage["skills"]:
                    html.append(f"<li>{skill}</li>")
                html.append("</ul>")
                html.append("</div>")

            html.append("</div>")

        html.append("</div>")
        html.append("</div>")

        return "\n".join(html)

    def render_gender_representation(self, representation_data: Dict[str, Any]) -> str:
        """
        Render a gender representation chart.

        Args:
            representation_data: Gender representation visualization data

        Returns:
            HTML string with visualization
        """
        if "error" in representation_data:
            return f"<div class='error'>{representation_data['error']}</div>"

        # In a real implementation, this would use a charting library
        # For this demo, we'll return a placeholder
        return f"""
        <div class='chart-container'>
            <h3>{representation_data['title']}</h3>
            <p class='chart-placeholder'>
                [Bar chart showing women's representation decreasing from
                {representation_data['series'][0]['data'][0]}% at entry level to
                {representation_data['series'][0]['data'][-1]}% at executive level]
            </p>
        </div>
        """

    def render_wage_gap(self, wage_gap_data: Dict[str, Any]) -> str:
        """
        Render a wage gap chart.

        Args:
            wage_gap_data: Wage gap visualization data

        Returns:
            HTML string with visualization
        """
        if "error" in wage_gap_data:
            return f"<div class='error'>{wage_gap_data['error']}</div>"

        # In a real implementation, this would use a charting library
        # For this demo, we'll return a placeholder
        return f"""
        <div class='chart-container'>
            <h3>{wage_gap_data['title']}</h3>
            <p class='chart-placeholder'>
                [Line chart showing wage gap increasing from
                ${wage_gap_data['series'][0]['data'][0]} at entry level to
                ${wage_gap_data['series'][0]['data'][-1]} at executive level]
            </p>
        </div>
        """

    def render_dashboard(self, dashboard_data: Dict[str, Any]) -> str:
        """
        Render a complete career dashboard.

        Args:
            dashboard_data: Complete dashboard data

        Returns:
            HTML string with complete dashboard
        """
        html = [
            "<!DOCTYPE html>",
            "<html>",
            "<head>",
            "<title>Women's Career Path Dashboard</title>",
            "<style>",
            "body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }",
            ".dashboard { max-width: 1200px; margin: 0 auto; }",
            ".profile-section { background: #f5f5f5; padding: 20px; border-radius: 5px; margin-bottom: 30px; }",
            ".skill-tag { display: inline-block; background: #007bff; color: white; padding: 5px 10px; margin: 5px; border-radius: 15px; }",
            ".chart-container { background: white; padding: 20px; border-radius: 5px; margin-bottom: 30px; border: 1px solid #ddd; }",
            ".career-timeline { background: white; padding: 20px; border-radius: 5px; margin-bottom: 30px; border: 1px solid #ddd; }",
            ".timeline-container { display: flex; justify-content: space-between; margin-top: 20px; }",
            ".timeline-stage { flex: 1; margin: 0 10px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }",
            ".timeline-year { font-weight: bold; color: #007bff; }",
            ".timeline-role { font-size: 18px; margin: 10px 0; }",
            ".action-section { background: white; padding: 20px; border-radius: 5px; margin-bottom: 30px; border: 1px solid #ddd; }",
            ".action-timeframe { display: flex; margin-bottom: 20px; }",
            ".action-timeframe-title { flex: 1; font-weight: bold; }",
            ".action-timeframe-items { flex: 3; }",
            ".chart-placeholder { background: #eee; padding: 40px; text-align: center; border-radius: 5px; }",
            "</style>",
            "</head>",
            "<body>",
            "<div class='dashboard'>",
            "<h1>Women's Career Path Dashboard</h1>"
        ]

        # Profile section
        profile = dashboard_data.get("profile", {})
        html.append("<div class='profile-section'>")
        html.append("<h2>Your Profile</h2>")
        html.append(f"<p><strong>Current Role:</strong> {profile.get('current_role', 'Not specified')}</p>")
        html.append(f"<p><strong>Industry:</strong> {profile.get('industry', 'Not specified')}</p>")
        html.append(f"<p><strong>Years Experience:</strong> {profile.get('years_experience', 0)}</p>")
        html.append(f"<p><strong>Career Stage:</strong> {profile.get('career_stage', 'Not specified')}</p>")

        html.append("<p><strong>Skills:</strong></p>")
        html.append("<div>")
        for skill in profile.get("skills", []):
            html.append(f"<span class='skill-tag'>{skill}</span>")
        html.append("</div>")

        if profile.get("aspirations"):
            html.append("<p><strong>Career Aspirations:</strong></p>")
            html.append("<ul>")
            for aspiration in profile.get("aspirations", []):
                html.append(f"<li>{aspiration}</li>")
            html.append("</ul>")

        html.append("</div>")

        # Career path timeline
        career_path = dashboard_data.get("career_path", {})
        html.append(self.render_career_timeline(career_path))

        # Action items section
        html.append("<div class='action-section'>")
        html.append("<h2>Recommended Action Items</h2>")

        for timeframe in dashboard_data.get("action_items", []):
            html.append("<div class='action-timeframe'>")
            html.append(f"<div class='action-timeframe-title'>{timeframe['timeframe']}</div>")
            html.append("<div class='action-timeframe-items'>")
            html.append("<ul>")
            for action in timeframe["actions"]:
                html.append(f"<li>{action}</li>")
            html.append("</ul>")
            html.append("</div>")
            html.append("</div>")

        html.append("</div>")

        # Close tags
        html.append("</div>")
        html.append("</body>")
        html.append("</html>")

        return "\n".join(html)

# Main application class for the Women's Career Path Visualizer
class WomensCareerPathApp:
    """
    Main application class that integrates the career recommendation and visualization
    components for a comprehensive women's career planning tool.
    """

    def __init__(self):
        self.career_advisor = CareerPathAnalyzerTool()
        self.visualizer = CareerPathVisualizer()

    def generate_career_plan(self,
                           current_role: str,
                           skills: List[str],
                           aspirations: List[str] = None,
                           industry: str = None,
                           years_experience: int = 0,
                           career_stage: str = "mid-level") -> Dict[str, Any]:
        """
        Generate a comprehensive women-focused career plan.

        Args:
            current_role: Current role
            skills: Current skills
            aspirations: Career aspirations
            industry: Industry
            years_experience: Years of experience
            career_stage: Career stage (entry-level, mid-level, senior, executive)

        Returns:
            Dictionary with complete career plan
        """
        enhanced_plan = self.career_advisor.generate_personalized_female_career_plan(
            current_role=current_role,
            skills=skills,
            aspirations=aspirations,
            industry=industry,
            years_experience=years_experience,
            career_stage=career_stage,
            include_gender_insights=True
        )

        return enhanced_plan

    def generate_report(self, enhanced_plan: Dict[str, Any]) -> str:
        """
        Generate a text report of the career plan.

        Args:
            enhanced_plan: Enhanced career plan

        Returns:
            Formatted text report
        """
        return self.career_advisor.generate_female_career_report(enhanced_plan)

    def generate_dashboard(self, enhanced_plan: Dict[str, Any]) -> str:
        """
        Generate an HTML dashboard for the career plan.

        Args:
            enhanced_plan: Enhanced career plan

        Returns:
            HTML dashboard
        """
        dashboard_data = self.career_advisor.create_dashboard_data(enhanced_plan)
        return self.visualizer.render_dashboard(dashboard_data)

    def get_insights_for_industry(self, industry: str, career_stage: str = "mid-level") -> Dict[str, Any]:
        """
        Get women-specific insights for a particular industry.

        Args:
            industry: Industry to get insights for
            career_stage: Career stage

        Returns:
            Dictionary with insights
        """
        return self.career_advisor.generate_women_in_tech_insights(
            industry=industry,
            career_stage=career_stage
        )

    def get_gender_gap_analysis(self, industry: str) -> Dict[str, Any]:
        """
        Get gender gap analysis for a particular industry.

        Args:
            industry: Industry to analyze

        Returns:
            Dictionary with analysis
        """
        return self.career_advisor.generate_gender_gap_analysis(industry)

    def save_report_to_file(self, report: str, filename: str) -> None:
        """
        Save a report to a file.

        Args:
            report: Report text
            filename: Output filename
        """
        with open(filename, "w") as f:
            f.write(report)

    def save_dashboard_to_file(self, dashboard: str, filename: str) -> None:
        """
        Save a dashboard to an HTML file.

        Args:
            dashboard: Dashboard HTML
            filename: Output filename
        """
        with open(filename, "w") as f:
            f.write(dashboard)

# Example usage of the application
def example_usage():
    """Example usage of the Women's Career Path Visualizer application"""
    app = WomensCareerPathApp()

    # Example user profile
    current_role = "Mid-level Developer"
    skills = ["Python", "Data Analysis", "Web Development", "Project Management", "Communication"]
    aspirations = ["Lead a technical team", "Develop expertise in AI/ML", "Work on high-impact projects"]
    industry = "Technology"
    years_experience = 4
    career_stage = "mid-level"

    # Generate career plan
    enhanced_plan = app.generate_career_plan(
        current_role=current_role,
        skills=skills,
        aspirations=aspirations,
        industry=industry,
        years_experience=years_experience,
        career_stage=career_stage
    )

    # Generate and save report
    report = app.generate_report(enhanced_plan)
    app.save_report_to_file(report, "career_plan_report.md")

    # Generate and save dashboard
    dashboard = app.generate_dashboard(enhanced_plan)
    app.save_dashboard_to_file(dashboard, "career_dashboard.html")

    print("Career plan generated successfully!")
    print("Report saved to career_plan_report.md")
    print("Dashboard saved to career_dashboard.html")

if __name__ == "__main__":
    example_usage()

